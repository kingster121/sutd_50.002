module debugger (
    input clk,         // clock
    input rst,         // reset
    input new_rx,      // new RX flag
    input rx_data[8],  // RX data
    output new_tx,     // new TX flag
    output tx_data[8], // TX data
    input tx_busy,      // TX is busy flag
    
    // Register
    input correct_button[32]
) {
    
    enum States {
        IDLE, 
        LOAD_DFF,
        SEND_CORRECT_BUTTON_PREFIX,
        SEND_CORRECT_BUTTON
    }
    
    const TEXT_CORRECT_BUTTON = $reverse("\nCorrect Button: ")
    const BIT_0 = "0"
    const BIT_1 = "1"
    
    .clk(clk) {
        .rst(rst) {
            dff state[$width(States)](#INIT(States.IDLE))
            dff bit_32_count[6](#INIT(0))
            dff correct_button_count[$clog2($width(TEXT_CORRECT_BUTTON, 0))]
            
            // Register dff
            dff correct_button_dff[32](#INIT(0))
        }
    }
    
    sig send_trigger   
    
    always {
        new_tx = 0 // defaults to no data
        tx_data = 8hxx // don't care
        
        send_trigger = new_rx & (rx_data == "h")
        
        case (state.q) {
            States.IDLE:
                if (send_trigger & !tx_busy) {
                    bit_32_count.d = 0
                    correct_button_count.d = 0
                    state.d = States.LOAD_DFF
                }
            
            States.LOAD_DFF:
                correct_button_dff.d = correct_button
                state.d = States.SEND_CORRECT_BUTTON_PREFIX
            
            States.SEND_CORRECT_BUTTON_PREFIX:
                if (!tx_busy) {
                    correct_button_count.d = correct_button_count.q + 1   // move to the next letter
                    new_tx = 1                            // send data
                    tx_data = TEXT_CORRECT_BUTTON[correct_button_count.q] // send letter from PROMPT_TEXT
                    if (correct_button_count.q == $width(TEXT_CORRECT_BUTTON, 0) - 1) // no more letters
                        state.d = States.SEND_CORRECT_BUTTON           // change states
                }
            
            States.SEND_CORRECT_BUTTON:
                if (!tx_busy) {
                    bit_32_count.d = bit_32_count.q + 1   // move to the next letter
                    new_tx = 1                            // send data  
                        
                    if (correct_button_dff.q[bit_32_count.q] == 1) 
                        tx_data = BIT_1
                    else
                        tx_data = BIT_0
                    
                    // no more letters
                    if (bit_32_count.q == 31) { 
                        bit_32_count.d = 0
                        state.d = States.IDLE           // change states
                    }
                }

            default:
                state.d = States.IDLE
        }
    }
}
